import json
import os
from concurrent import futures
import ast
import numpy as np
import traceback
from model_pb2_grpc import *
import psycopg
import sql
import model_pb2_grpc
from psycopg import sql as pgsql
from model_pb2 import RecallRequest, RecallResponse, GetRatingResponse

"""
accompanied modules are generated by calling the following command

```
python3 -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. model.proto
```

"""

class RecwaveModelService(ModelServicer):
    def __init__(self):
        super(RecwaveModelService, self).__init__()
        generator_path = os.environ.get("GENERATOR_PATH", "../generator")
        with open(os.path.join(generator_path, 'items.json')) as items_json, open(os.path.join(generator_path, 'users.json')) as users_json:
            items = json.load(items_json)
            users = json.load(users_json)
            items_dict = {i['itemid']: i for i in items}
            users_dict = {u['userid']: u for u in users}
            self.items = items_dict
            self.users = users_dict
        self.conn = psycopg.connect("dbname=dev user=root host=127.0.0.1 port=4566")


    def GetRating(self, request, context):
        try:
            print(f"GetRating from {request.userid}")
            userid, itemid, feature_iter = request.userid, request.itemid, request.feature_values
            with self.conn.cursor() as cur:
                cur.execute(sql.GET_MOST_INTERACTED % userid)
                result = cur.fetchall()
                if len(result) == 0:
                    context.set_code(grpc.StatusCode.OK)
                    return GetRatingResponse(userid=userid, itemid=itemid, rating=0)
                result_str = str(result[0][0])
                start_index = result_str.rfind(',') + 1
                end_index = result_str.rfind(')')
                return_userid = result_str[start_index:end_index]
            # the similarity between the most interacted item and the current one
            items = list(self.items[itemid].values())
            items.pop(0)
            items_return = list(self.items[return_userid].values())
            items_return.pop(0);
            # print(f"result from {items}, {items_return}")
            vec1 = np.array(items)
            vec2 = np.array(items_return)

            score = vec1.dot(vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))
            # print(f"result from {score}")
            return GetRatingResponse(userid=userid, itemid=itemid, rating=score)
        except Exception as e:
            print(traceback.format_exc())
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(e)
            return RecallResponse(userid=userid, itemid=[])

    def Recall(self, request, context):
        userid = request.userid
        print(f"Recall request from {userid}")
        try:
            with self.conn.cursor() as cur:
                cur.execute(sql.RECALL_SQL % userid)
                results = cur.fetchall()
                print(results)
                if len(results) < 20:
                    # randomly pick 20 items
                    context.set_code(grpc.StatusCode.OK)
                    print(f"Recall random keys for {userid}")
                    return RecallResponse(userid=userid,
                        itemid=np.random.choice(list(self.items.keys()), 20))
                else:
                    # if not, return the recalled items
                    context.set_code(grpc.StatusCode.OK)
                    print(f"Recall sorted keys for {userid}")
                    return RecallResponse(userid=userid,
                        itemid=[str(r[0]) for r in results])
        except Exception as e:
            print(traceback.format_exc())
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(e)
            return RecallResponse(userid=userid, itemid=[])

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close()

    def serve(self):
        server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
        model_pb2_grpc.add_ModelServicer_to_server(
            self, server)
        server.add_insecure_port('[::]:8080')
        server.start()
        server.wait_for_termination()


if __name__ == '__main__':
    for i in range(1):
        print("making the", i, "th connection")

        conn = psycopg.connect("dbname=dev user=root host=127.0.0.1 port=4566")
        with conn.cursor() as cur:
            # the following code will panic
            # because placeholder is completely not supported
            # even varchar parsed to TypeOid 0, which isn't even defined
            cur.execute("select (2, %s);", ("2333333",))
            # cur.execute("select (2, $1);")
            results = cur.fetchall()
        print(results)

        conn.close()
